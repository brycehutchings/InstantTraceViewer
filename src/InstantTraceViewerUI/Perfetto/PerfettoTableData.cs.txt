// Uncomment to diagnose parsing/lookup problems.
// #define DEBUG_PARSING

namespace Tabnalysis
{
    using Perfetto.Protos;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;

    public class PerfettoTableData : ITableData
    {
        private const int ColumnCount = 9;

        private struct Row
        {
            public int Pid;
            public string ProcessName;
            public int Tid;
            public string ThreadName;
            public string Name;
            public string Kind;
            public string Category;
            public ulong BootTimestamp;
            public ulong? RealtimeTimestamp;
            public string Data;
        }

        // ui.perfetto.dev appears to use the earliest time as time 0 so match that behavior here.
        private ulong? earliestBootTimestamp = 0;

        private readonly FileStream fileStream;
        private readonly List<Row> rows = new List<Row>();
        private bool disposed;

        public event OnRowsAdded OnRowsAdded;

        public ReaderWriterLockSlim TableLock { get; } = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);

        public int RowCount => this.rows.Count;

        public int MaximumColumnCount { get; private set; } = ColumnCount;

        public PerfettoTableData(string file, OnRowsAdded onRowsAdded = null)
        {
            // Open a file stream in order to enable file sharing.
            this.fileStream = new FileStream(file, FileMode.Open, FileAccess.Read);
            this.OnRowsAdded = onRowsAdded;
            Task.Run(() => this.BackgroundReader());
        }

        private static DateTimeOffset RealTimeClockToDateTimeOffset(ulong timestamp)
        {
            var unixTime = (long)(timestamp / 1000000000);
            var unixTimeFraction = (long)(timestamp % 1000000000); // Fraction of a second in nanoseconds.
            return DateTimeOffset.FromUnixTimeSeconds(unixTime) + TimeSpan.FromTicks(unixTimeFraction / 100);
        }

        private string TimestampToString(ulong bootTimestamp)
        {
            ulong traceStartTimestamp = bootTimestamp - (earliestBootTimestamp ?? 0);
            return (traceStartTimestamp / 1000000000.0).ToString(".000000");
        }

        public int ReadRow(int rowIndex, string[] row)
        {
            if (rowIndex == 0)
            {
                row[0] = "Pid";
                row[1] = "ProcessName";
                row[2] = "Tid";
                row[3] = "ThreadName";
                row[4] = "Name";
                row[5] = "Kind";
                row[6] = "Category";
                row[7] = "Timestamp";
                row[8] = "Data";
            }
            else
            {
                var rowData = this.rows[rowIndex - 1];  // - 1 because row 0 is a fake header row.
                row[0] = rowData.Pid.ToString();
                row[1] = rowData.ProcessName;
                row[2] = rowData.Tid.ToString();
                row[3] = rowData.ThreadName;
                row[4] = rowData.Name;
                row[5] = rowData.Kind;
                row[6] = rowData.Category;
                row[7] =
                    rowData.RealtimeTimestamp.HasValue ? 
                        RealTimeClockToDateTimeOffset(rowData.RealtimeTimestamp.Value).ToString("MM-dd HH:mm:ss.ffffff") :
                        TimestampToString(rowData.BootTimestamp);
                row[8] = rowData.Data;
            }

            for (int i = ColumnCount; i < row.Length; i++) // Fill in any missing columns.
            {
                row[i] = string.Empty;
            }

            return ColumnCount;
        }

        public void Dispose()
        {
            if (!this.disposed)
            {
                this.disposed = true;

                this.fileStream.Dispose();
            }
        }

        private void BackgroundReader()
        {
            try
            {
                Trace trace = Trace.Parser.ParseFrom(this.fileStream);

                var internedStringManager = new InternedStringManager();
                var trackDescriptorManager = new TrackDescriptorManager();

                var clockSync = new PerfettoClockConverter(trace);
                ProcessClockSnapshots(clockSync);

                // First pass: Preprocess packets for interned strings and track descriptors.
                foreach (var packet in trace.Packet)
                {
                    trackDescriptorManager.ProcessPacket(packet);
                }

                var groupPacketSizes = new Dictionary<string, long>();
                Action<string, int> addPacketSize = (name, size) =>
                {
                    long totalSize = 0;
                    groupPacketSizes.TryGetValue(name, out totalSize);
                    totalSize += size;
                    groupPacketSizes[name] = totalSize;
                };

                int packetCount = 0;
                foreach (var packet in trace.Packet)
                {
                    //#if DEBUG_PARSING
                    //                    System.Diagnostics.Debug.Print($"Packet DataCase={packet.DataCase} Timestamp={packet.Timestamp} TrustedPacketSequenceId={packet.TrustedPacketSequenceId} TrustedUid={packet.TrustedUid}");
                    //#endif

                    // Interned strings may be reset or overridden and so the interned string manager can't be precomputed. It must be used as it is consuming packets.
                    internedStringManager.ProcessPacket(packet);

                    if (packet.SystemInfo != null)
                    {
                        ProcessSystemInfo(packet);

                        addPacketSize("SystemInfo", packet.CalculateSize());
                    }
                    else if (packet.TraceConfig != null)
                    {
                        // TODO: Enumerate buffers and data sources
                    }
                    else if (packet.TrackEvent != null)
                    {
                        string sizeId = ProcessTrackEvent(packet, internedStringManager, trackDescriptorManager, clockSync);
                        addPacketSize(sizeId ?? "OtherTrackEvent", packet.CalculateSize());
                    }
                    else if (packet.AndroidLog != null)
                    {
                        ParseAndroidLogEvent(packet, trackDescriptorManager, clockSync);
                        addPacketSize("Logcat", packet.CalculateSize());
                    }
                    else if (packet.PerfSample != null)
                    {
                        // Stack sampling ignored. Too noisy and not intended for a log viewer.
                    }
                    else if (packet.FtraceEvents != null)
                    {
                        addPacketSize("FTrace", packet.CalculateSize());

                        foreach (var e in packet.FtraceEvents.Event)
                        {
                            if (e.EventCase == FtraceEvent.EventOneofCase.Print)
                            {
                                // e.Pid = Tid ????
                                // e.buf.Split("|") ???? B|PID|Message\n ????
                            }

                            /*var row = new Row
                            {
                                Pid = 0,
                                ProcessName = "",
                                Tid = 0,
                                ThreadName = "",
                                Name = $"FTrace[{e.EventCase}]",
                                Kind = "",
                                Category = "",
                                Timestamp = packet.Timestamp,
                                Data = e.ToString()
                            };
                            rows.Add(row);*/
                        }
                    }
                    else
                    {
                        /*var row = new Row
                        {
                            Pid = 0,
                            ProcessName = "",
                            Tid = 0,
                            ThreadName = "",
                            Name = $"{packet.DataCase}",
                            Kind = "",
                            Category = "",
                            Timestamp = packet.Timestamp,
                            Data = packet.ToString()
                        };
                        rows.Add(row);*/
                    }

                    packetCount++;
                    if ((packetCount % 20000) == 0)
                    {
                        this.OnRowsAdded?.Invoke((float)packetCount / trace.Packet.Count(), null);
                    }
                }

                earliestBootTimestamp = rows.Where(r => r.BootTimestamp != 0).Min(r => r.BootTimestamp);

                // Finally sort all of the events chronologically.
                rows.Sort((left, right) =>
                {
                    return (left.RealtimeTimestamp < right.RealtimeTimestamp) ? -1 :
                           (left.RealtimeTimestamp > right.RealtimeTimestamp) ? 1 : 0;
                });

                foreach (var size in groupPacketSizes.OrderBy(kvp => kvp.Value))
                {
                    var row = new Row
                    {
                        Kind = "AggregatedPacketSizes",
                        ThreadName = string.Empty,
                        ProcessName = string.Empty,
                        Category = string.Empty,
                        RealtimeTimestamp = 0,
                        Name = size.Key,
                        Data = $"{size.Value / 1024}KB"
                    };
                    rows.Insert(0, row);
                }

                this.OnRowsAdded?.Invoke(1.0f, null);
            }
            catch (Exception ex)
            {
                this.OnRowsAdded?.Invoke(null, ex);
            }
            finally
            {
                this.fileStream.Close();
            }
        }

        private static Dictionary<uint, Stack<string>> sliceBeginNames = new Dictionary<uint, Stack<string>>();

        private string ProcessTrackEvent(TracePacket packet, InternedStringManager internedStringManager, TrackDescriptorManager trackDescriptorManager, PerfettoClockConverter clockConverter)
        {
            string kind = $"TrackEvent[{packet.TrackEvent.Type}]";

            // Use the provided non-interned name if available.
            string name = string.Empty;
            if (packet.TrackEvent.NameFieldCase == TrackEvent.NameFieldOneofCase.NameIid)
            {
                name = internedStringManager.GetInternedEventName(packet, packet.TrackEvent.NameIid);
            }
            else if (packet.TrackEvent.NameFieldCase == TrackEvent.NameFieldOneofCase.Name)
            {
#if DEBUG_PARSING
                Debug.Print($"  TrackEvent Name={packet.TrackEvent.Name}");
#endif
                name = packet.TrackEvent.Name;
            }

            // Later versions of Perfetto do not store the event name with the SliceEnd. Instead if must be inferred using a stack.
            // TODO: Handle packet.SequenceFlags & SEQ_INCREMENTAL_STATE_CLEARED?

            if (!string.IsNullOrEmpty(name) && packet.TrackEvent.Type == TrackEvent.Types.Type.SliceBegin)
            {
                Stack<string> nameStack = null;
                if (sliceBeginNames.TryGetValue(packet.TrustedPacketSequenceId, out nameStack))
                {
                    nameStack.Push(name);
                } else
                {
                    nameStack = new Stack<string>(new [] { name });
                    sliceBeginNames.Add(packet.TrustedPacketSequenceId, nameStack);
                }
            }
            else if (string.IsNullOrEmpty(name) && packet.TrackEvent.Type == TrackEvent.Types.Type.SliceEnd)
            {
                Stack<string> nameStack = null;
                if (sliceBeginNames.TryGetValue(packet.TrustedPacketSequenceId, out nameStack) && nameStack.Count > 0)
                {
                    name = nameStack.Pop();
                }
                else
                {
                    name = "!!!MatchingSliceBeginMissing!!!";
                }
            }

            // I am unsure if these are exclusive but I just combine them.
            var categories = new List<string>();
            categories.AddRange(packet.TrackEvent.Categories);
            categories.AddRange(packet.TrackEvent.CategoryIids.Select(ciid => internedStringManager.GetInternedCategoryName(packet, ciid)));

            // See https://github.com/google/perfetto/blob/21753a5bd0877d6b7aac4bea0b593d3f8e55cfef/src/trace_processor/util/debug_annotation_parser.cc
            var textSb = new StringBuilder();
            string sizeGroupId = null;
            foreach (var debugAnnotation in packet.TrackEvent.DebugAnnotations)
            {
                string debugAnnotationName = string.Empty;
                if (debugAnnotation.HasNameIid && debugAnnotation.NameFieldCase == DebugAnnotation.NameFieldOneofCase.NameIid)
                {
                    debugAnnotationName = internedStringManager.GetInternedDebugAnnotationName(packet, debugAnnotation.NameIid);
                }
                else if (debugAnnotation.HasName)
                {
                    debugAnnotationName = debugAnnotation.Name;
                }
                else
                {
                    debugAnnotationName = "???";
                }

                var debugAnnotationValue = GetDebugAnnotationStringValue(debugAnnotation);
                textSb.Append($"{debugAnnotationName}={debugAnnotationValue} ");
            }

            if (textSb.Length > 0)
            {
                textSb.Length--; // Remove trailing space
            }

            ThreadDescriptor threadDescriptor = trackDescriptorManager.GetThreadDescriptor(packet);
            ProcessDescriptor processDescriptor = trackDescriptorManager.GetProcessDescriptor(packet, threadDescriptor);

            var row = new Row
            {
                Pid = processDescriptor?.Pid ?? threadDescriptor?.Pid ?? 0,
                ProcessName = processDescriptor?.ProcessName ?? string.Empty,
                Tid = threadDescriptor?.Tid ?? 0,
                ThreadName = threadDescriptor?.ThreadName ?? string.Empty,
                Name = name,
                Kind = kind,
                Category = string.Join(", ", categories),
                BootTimestamp = packet.Timestamp,
                RealtimeTimestamp = clockConverter.ConvertTimestamp(BuiltinClock.Boottime, BuiltinClock.Realtime, packet.Timestamp),
                Data = textSb.ToString()
            };
            rows.Add(row);

            sizeGroupId = name;
            return sizeGroupId;
        }

        private void ProcessClockSnapshots(PerfettoClockConverter clockSync)
        {
            foreach (var clockSnapshot in clockSync.ClockSnapshots)
            {
                var bootTimeClock = clockSnapshot.Clocks.SingleOrDefault(c => c.ClockId == (int)BuiltinClock.Boottime);
                var realtimeClock = clockSnapshot.Clocks.SingleOrDefault(c => c.ClockId == (int)BuiltinClock.Realtime);
                if (bootTimeClock != null && realtimeClock != null)
                {
                    var row = new Row
                    {
                        Kind = "ClockSnapshot",
                        ThreadName = string.Empty,
                        ProcessName = string.Empty,
                        Category = string.Empty,
                        RealtimeTimestamp = 0,
                        Name = "RealtimeClockSnapshot",
                        Data = $"{TimestampToString(bootTimeClock.Timestamp)} = {RealTimeClockToDateTimeOffset(realtimeClock.Timestamp).ToString("yyyy-MM-dd HH:mm:ss.ffffff")}"
                    }; // fixme: should be corrected based on start time
                    rows.Add(row);
                }
            }
        }

        private void ProcessSystemInfo(TracePacket packet)
        {
            var row = new Row { Kind = "SystemInfo", ThreadName = string.Empty, ProcessName = string.Empty, Category = string.Empty, RealtimeTimestamp = packet.Timestamp };

            if (packet.SystemInfo.HasAndroidBuildFingerprint)
            {
                row.Name = "android_build_fingerprint";
                row.Data = packet.SystemInfo.AndroidBuildFingerprint;
                rows.Add(row);
            }

            if (packet.SystemInfo.HasTracingServiceVersion)
            {
                row.Name = "tracing_service_version";
                row.Data = packet.SystemInfo.TracingServiceVersion;
                rows.Add(row);
            }

            if (packet.SystemInfo.Utsname.HasVersion)
            {
                row.Name = "uts_name.version";
                row.Data = packet.SystemInfo.Utsname.Version;
                rows.Add(row);
            }

            if (packet.SystemInfo.Utsname.HasSysname)
            {
                row.Name = "uts_name.sysname";
                row.Data = packet.SystemInfo.Utsname.Sysname;
                rows.Add(row);
            }

            if (packet.SystemInfo.Utsname.HasMachine)
            {
                row.Name = "uts_name.machine";
                row.Data = packet.SystemInfo.Utsname.Machine;
                rows.Add(row);
            }

            if (packet.SystemInfo.Utsname.HasRelease)
            {
                row.Name = "uts_name.release";
                row.Data = packet.SystemInfo.Utsname.Release;
                rows.Add(row);
            }
        }

        private void ParseAndroidLogEvent(TracePacket packet, TrackDescriptorManager trackDescriptorManager, PerfettoClockConverter clockSync)
        {
            foreach (var evt in packet.AndroidLog.Events)
            {
                var pid = evt.HasPid ? evt.Pid : 0;
                var tid = evt.HasTid ? evt.Tid : 0;
                var message = evt.HasMessage ? evt.Message : string.Empty;
                var name = evt.HasTag ? evt.Tag : string.Empty;

                // TODO: Use evt.Timestamp to avoid incorrect time, but it uses a different clock that requires conversion.
                string kind;
                if (evt.HasLogId)
                {
                    kind = evt.LogId == AndroidLogId.LidCrash ? "Crash" :
                        evt.LogId == AndroidLogId.LidDefault ? "Default" :
                        evt.LogId == AndroidLogId.LidEvents ? "Events" :
                        evt.LogId == AndroidLogId.LidKernel ? "Kernel" :
                        evt.LogId == AndroidLogId.LidRadio ? "Radio" :
                        evt.LogId == AndroidLogId.LidSecurity ? "Security" :
                        evt.LogId == AndroidLogId.LidStats ? "Stats" :
                        evt.LogId == AndroidLogId.LidSystem ? "System" : "Unkown";
                }
                else
                {
                    kind = "None";
                }

                string priority = string.Empty;
                if (evt.HasPrio)
                {
                    priority = evt.Prio == AndroidLogPriority.PrioUnused ? "Unused" :
                        evt.Prio == AndroidLogPriority.PrioVerbose ? "Verbose" :
                        evt.Prio == AndroidLogPriority.PrioDebug ? "Debug" :
                        evt.Prio == AndroidLogPriority.PrioInfo ? "Info" :
                        evt.Prio == AndroidLogPriority.PrioWarn ? "Warn" :
                        evt.Prio == AndroidLogPriority.PrioError ? "Error" :
                        evt.Prio == AndroidLogPriority.PrioFatal ? "Fatal" : "Unknown";
                }

                ProcessDescriptor processDescriptor = trackDescriptorManager.GetProcessDescriptorByPid(pid);
                ThreadDescriptor threadDescriptor = trackDescriptorManager.GetThreadDescriptorByTid(tid);

                // Logcat timestamp is Realtime but remainder of events are Boottime (I think).
                var bootTimestamp = clockSync.ConvertTimestamp(BuiltinClock.Realtime, BuiltinClock.Boottime, evt.Timestamp);
                if (bootTimestamp == null)
                {
                    // The packet timestamp is imprecise and probably is the time this chunk of logcat events were emitted to perfetto but it is better than nothing.
                    bootTimestamp = packet.Timestamp;
                }

                var row = new Row
                {
                    Pid = pid,
                    ProcessName = processDescriptor?.ProcessName ?? string.Empty,
                    Tid = tid,
                    ThreadName = threadDescriptor?.ThreadName ?? string.Empty,
                    Name = name,
                    Kind = $"Logcat[{kind}]",
                    Category = priority,
                    BootTimestamp = bootTimestamp.Value,
                    RealtimeTimestamp = evt.Timestamp,
                    Data = message
                };
                rows.Add(row);
            }
        }

        // See DebugAnnotationParser::ParseDebugAnnotationValue
        private static string GetDebugAnnotationStringValue(DebugAnnotation debugAnnotation)
        {
            switch (debugAnnotation.ValueCase)
            {
                case DebugAnnotation.ValueOneofCase.None:
                    return string.Empty;
                case DebugAnnotation.ValueOneofCase.BoolValue:
                    return debugAnnotation.BoolValue.ToString();
                case DebugAnnotation.ValueOneofCase.UintValue:
                    return debugAnnotation.UintValue.ToString();
                case DebugAnnotation.ValueOneofCase.IntValue:
                    return debugAnnotation.IntValue.ToString();
                case DebugAnnotation.ValueOneofCase.DoubleValue:
                    return debugAnnotation.DoubleValue.ToString();
                case DebugAnnotation.ValueOneofCase.StringValue:
                    return debugAnnotation.StringValue;
                case DebugAnnotation.ValueOneofCase.PointerValue:
                    return debugAnnotation.PointerValue.ToString("X");
                case DebugAnnotation.ValueOneofCase.NestedValue:
                    // This annotation type is marked as deprecated.
                    return GetDebugAnnotationNestedValueStringValue(debugAnnotation.NestedValue);
                case DebugAnnotation.ValueOneofCase.LegacyJsonValue:
                    return debugAnnotation.LegacyJsonValue;
            }

            if ((debugAnnotation.ArrayValues?.Count ?? 0) > 0)
            {
                // TODO: Is this right? Do I just ignore the Values on this annotation? Why isn't this one of the "ValueCase"?
                return $"[{string.Join(", ", debugAnnotation.ArrayValues.Select(a => GetDebugAnnotationStringValue(a)))}]";
            }

            if (debugAnnotation.DictEntries != null)
            {
                return "<UNSUPPORTED DICTIONARY>";
                // TODO: Do I just ignore the Values on this annotation? Why isn't this one of the "ValueCase"?
                // TODO: Implement me.
            }

            return string.Empty;
        }

        private static string GetDebugAnnotationNestedValueStringValue(DebugAnnotation.Types.NestedValue nestedValue)
        {
            if (nestedValue.HasIntValue)
            {
                return nestedValue.IntValue.ToString();
            }
            else if (nestedValue.HasBoolValue)
            {
                return nestedValue.BoolValue.ToString();
            }
            else if (nestedValue.HasDoubleValue)
            {
                return nestedValue.DoubleValue.ToString();
            }
            else if (nestedValue.HasStringValue)
            {
                return nestedValue.StringValue;
            }
            // nestedValue.NestedType is unspecified when the NestedValue contains array data so it is ignored.
            else if (nestedValue.ArrayValues?.Count > 0)
            {
                return $"[{string.Join(", ", nestedValue.ArrayValues.Select(av => GetDebugAnnotationNestedValueStringValue(av)))}]";
            }
            else if (nestedValue.DictKeys?.Count > 0)
            {
                System.Diagnostics.Debug.Assert(nestedValue.DictKeys.Count == nestedValue.DictValues.Count);
                return $"[{string.Join(", ", nestedValue.DictKeys.Select((dk, i) => $"{dk}={GetDebugAnnotationNestedValueStringValue(nestedValue.DictValues[i])}"))}]";
            }

            return "UNSPECIFIED NESTED VALUE TYPE";
        }
    }
}
